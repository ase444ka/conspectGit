<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конспект скринкаста по GIT</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    
<pre>
<h1>Конфигурация</h1>
<h2>01 Основная конфигурация</h2>
<p>
<strong>git init</strong> создает репозиторий в папке проекта
<strong>git config user.name 'Ваше Имя'</strong>
<strong>git congit user.email</strong>
<strong>cat .git/config</strong>
<strong>git config diff.png.textconv "identify --format '%wx%h %b\n'"</strong> даст в конфиге строку:
<strong>
    [diff "png"]
        textconv = identify --format '%wx%h %b\n'
</strong>
уровни конфигурации
<strong>--system</strong> на уровне системы хран в директ git/etc В program files
<strong>--global</strong> на ур. пользователя обычно лежат в папке пользователя. где они хранятся, 
определяет формат XDG: путь хранится в переменной окружения
<strong> $XDG_CONFIG</strong>_HOME -если она вдруг есть, надо переместить из папки пользователя свой конфиг туда
эта перем. работает и для .gitignore И для .gitattributes
если ее нет, то в $HOME/.config
<strong>--local</strong> локальные (по дефолту)

<strong>git config --list</strong> просмотр конфигурации из всех конфигов
<strong>git congit --list --global</strong> только глоб.
<strong> git config --unset</strong> убрать параметры
<strong>git config --remove-section</strong> user удалит всю секцию

<strong>git config -h</strong> вызвать хелп краткий
<strong>git help config </strong>откроет подробный хелп

<em>ЛИСТАЛКА ПО УМОЛЧАНИЮ</em> в гит - less
<strong>f</strong> - листать дальше
<strong>q</strong> - выйти
<strong>g</strong> - в начало
<strong>/чтото</strong> ищет чтото
<strong>n</strong> поиск вперед
<strong>шифт n</strong> поиск назад
<strong>git config --global core.pager 'less-RFX'</strong>
</p>
<h2>02 Настройка редактора</h2>
<strong>
git config --global --edit == git config --global -e
</strong>    
по умолчанию редактор vim
<strong>git config --global core.editor \"C:\\Users\\istom\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\" --wait  </strong>
-w чтобы редактор не закрывался сам, и гит его ждал для разных редакторов разные ключи




<h2>03 Алиасы (псевдонимы для команд)</h2>

<strong>git config --global alias.c 'config --global'</strong>
теперь git c вызовет конфиг
можно сделать алиас на несколько команд, тогда нужен воскл. знак
<strong>git config alias.sayhi '!echo 'git ...'; 'git ...'</strong>
разделять тчк с зпт

<h2>04 Проблема с переводами строк Windows/Linux</h2>

под юникс-системами перевод стр. кодируется 1 байтом 0a(<em>LF: "Line Feed"</em>)
windows 2 байта 0d 0a (<em>CR LF Caret Return Line Feed</em>)
м.б. проблемы при командной разработке


<h2>05 Настройка core.autocrlf для нормализации переводов строк</h2>

в конфиге
<strong>core.autocrlf true</strong> в гит crlf заменяется на lf а когда он отдает нам ф. обратно, заменяет обратно
lf на crlf отл. вар. для виндовс
<strong>core.autocrlf input</strong> односторонняя конвертация в гит переводится в lf обратно - lf
это отл. вариант для юникс
false ничего не делает с файлами
чтобы определить, текстовый или бинарн. ф., гит смотрит на его содержимое
к сожалению, он иногда ошибается и повреждает ф. при смене crlf на lf

<h2>08 Атрибуты: .gitattributes, text, eol</h2>

настраивается к каким файлам применять какие настройки
например:
<strong>
    * text = auto
    
    #force text set
    *.html text
    *.js text
    *.css text
    
    # Windows files (need crlf)
    *.sln text eol=crlf
    *.bat eol=crlf
    
    #Unix files (need LF) set to a value
    *.sh eol=lf
    
    #binary files - unset attr.
    *.jpg -text     
    *.gif -text
</strong>

м.б. еще <em>Unspecified</em>. Настройки снизу перекрывают те что сверху
<strong>eol</strong> - что делать  с переводами строки при взятии  из git В раб. директ.

для текстовых ф. включается нормализация  - при переводе в git Становятся lf

часто вместо -text Ставят <strong>binary</strong>. это т.ж. самое что <strong>-text -merge -diff</strong>

если стоит eol это автоматич. подразумевает текстовые ф. Значение lf забавное - оно не меняет строки.
 Т.е. просто при чтении из гит переводы не меняются!!если eol нет git ориентируется на конфиг и ос.

можно в атрибутах указать так * -text и тогда у всех ф. отключатся переводы строк
.gitattributes очень рекомендуется иметь, он хранится в директории проекта, для 
командной разработки, чтобы у всех были настроены правильные переводы строк,
 и чтобы гит не повредил содержимое бинарных файлов
гит ищет атрибуты так:
<strong>.git/info/attributes </strong>- локальные атрибуты
<strong>./gitattributes</strong> В дир. с целевым файлом
потом выше выше до корня проекта
потом в  <strong>config: core.attributesFile</strong>
<strong>git config --global core.attributesFile ~/.gitattributes</strong>
<strong>(default) $XDG_CONFIG_HOME/git/attributes</strong>
<strong>/.config/git/atttibutes</strong> - Если перем. выше не указана
<strong>/etc/gitattributes   /program files/git/etc/gitattributes</strong>

полная справка <strong>git help attributes</strong>


<h2>07 Игнорирование: .gitignore</h2>
<strong>
    #OS-level helper (cache. folder preferences)
    Thumbs.db
    #path/to/anywhere/Thumbs.db
    .Ds_Store
    # any/folder/.Ds_Store
    
    #Logs
    *.log
    # anywhere.my.log. NOT my.logs, my.log.tmp
    
    #Compiled files
    *.class
    *.py[co]
    #same as: *.pyc OR *.pyo NOT *.pyco
    
    migrate-201[5-7]*
    #anywhere/migrate-2015, migrate-20170101.db, NOT migrate-2018...
    
    *.py?
    #anywhere/*.py&lt;any char&gt;, *.pyc OR *pyd NOT *.py
    
    #slash at the end means a folder
    build/
    # folder "build", NOT file "build"
    #if there is not slash may be directories or files
    
    #patterns above match anywhere in the project
    #/build
    #/scripts/build
    
    #PATH-AWARE MODE если слэш где-то кроме как в конце, ищется от корня
    /build/
    #build, but NOT scripts/build
    
    #in slash mode match relative to .gitignore
    secret/key
    #secret/key, NOT docs/secret/key
    
    doc/*.html
    #doc/file.html, NOT somewhere/doc/file.html
    
    /*.txt
    # my.txt, NOT somewhere/my.txt
    
    #wildcard matches within a path segment
    var/www*/tmp
    # var/www/tmp
    # var/www-home/tmp
    # NOT var/www/info/tmp
    
    #...or replaces a path segment 
    users/*/private
    #users/john/private
    #users/alice/private
    #NOT
    #users/private
    #users/john/protect/private
    
    #double wildcard ** replaces any number of path segments
    **/*.log
    #same as *.log
    
    **/app/cache
    #shop/app/cache
    #main/front/cache
    
    docs/**/*.html
    #docs/module/generated.html
    #docs/general/info/performance.html
    #NOT
    #subdir/docs/my.html
    
    #** can only be used as **/...
    #or .../**/,,,
    #or .../**
    
    .*
    !.gitattributes
    !.gitignore
    
    #DOESN'T WORK
    #install/ ignores directory, making its content unknown to git
    # so we can't "unignore" anything inside it
    /install/
    !install/packages.xml
    
    #INSTEAD
    #ignore not install/, but each item of its content
    # this way we can "unignore" it
    /install/*
    !install/packages.xml

</strong>    
проверка
<strong>git check-ignore -v install/something</strong>

Файлы с гитигнорами
<strong>
    папкапроекта/.../.gitignore  игнорирует относительно гитигнор
    папкапроекта/.git/info/exclude файл exclude не передается коллегам
</strong>
в конфиге <strong>core.excludesFile</strong>
<strong>
    git config --global core.excludesFile ~/.gitignore
    (default) $XDG_CONFIG_HOME/git/ignore
</strong>
 Если нет перем. <strong>~/.config/git/ignore</strong>  сюда можно 
записать файлы специф. для системы, например, Thumbs.db

<h2>08 Подключение файлов в конфиг: include</h2>
Если большой конфиг
<strong>git config include.path ../gitconfig</strong>
относит путь отсчит от ф. конфигурации, то есть:
<strong>.git/config -> project/gitconfig</strong>
 если вызвать конфиг с одинак. ключом несколько раз, последняя настройка 
перезапишет предыдущую, чтобы не перезаписала:
<strong>git config --add include.path ../gitconfig</strong>
т.о. можно структурировать сложн. конфиг или повторно использовать
условный инклюд в глобальном конфиге:
<strong>
    [includeIf "gitdir: ~/company/"]
    	path = ~/company/gitconfig
</strong>



<h1>ОСНОВЫ</h1>

<h2>01 Создание репозитория, первый коммит</h2>

<strong>git init</strong> созд. репозиторий .git/
есть раб. директория - индекс - репозиторий
желательно в коммите первая строка с большой буквы без точки в конце и отделялась пустой строкой


<h2>02 Git и права на файлы</h2>

<strong>create mode 100644  index.html</strong>
<strong>100</strong>-Файл
<strong>644</strong> - права на файл - исполнимый для текущего пользователя или нет <em>644</em> нет <em>755</em> да
<strong>git config core.fileMode false</strong>
<strong>git update-index --chmod=+x index.html</strong> ставит исполнимость напрямую в индексе в обход ф.с.
<strong>git add --chmod=+x index.html </strong> Если ф. еще не было в индексе

<h2>03 Git show, автор и коммиттер</h2>

<strong>git show hash</strong>
<strong>git show</strong>   покажет текущий коммит
<strong>git show --pretty=fuller</strong>
Автор и комиттер разные
<strong>git commit --author='Dyadya Vasya <vas@vas.ru>'  --date='...'</strong>

<h2>04 Добавление файлов и директорий, git status</h2>

пустые директории гит не добавляет
туда можно положить пустой ф <strong>.gitkeep</strong>
<strong>git add .</strong> добавит все новое
если добавилось что-то не то, можно убрать:
<strong>git reset HEAD .idea</strong>
<strong>ls -a</strong> покажет содержимое текущей директории
даже если что-то в гитигноре, мы можем добавить это в индекс:
<strong>git add --force .idea/project.html</strong> == <strong>git add -f .idea/project.html</strong>
и впредь изменения в этом ф. б. отслежив.
<strong>git commit -m</strong> позв. указать сообщение без редактора

<h2>05 Хороший коммит</h2>

коммиты д.б. атомарными, консистентными, ничего не ломать
функциональность: что сделали
характер(компонент): что сделали


<h2>06 Зачем нужен индекс?</h2>

чтобы разделять изменения по разным коммитам, и не нарушать принцип атомарности

<strong>git add -p index.html</strong>  тогда гит для каждого фрагмента в ф. предложит нам решить, добав
-лять его в индекс или нет

<h2>07 Коммиты без git add</h2>

<strong>git commit --all </strong>== <strong>git commit -a</strong>
<strong>git commit -a -m "oloolo"</strong> == <strong>git commit -am "ololo"</strong>
<strong>-a</strong> игнорирует ф. кот. не отслеживаются гитом
если у нас что-то сделано, что-то в индексе, что-то не в индексе, 
но нам нужно срочно изменить и закоммитить другой ф.
<strong>git commit -m 'Ignore logs' .gitignore</strong>  доб. в индекс и закоммитит остальные оставит, но только
если гитигнор уже отслеживается
если хочется все добавл. в индекс и коммитить даже новое:
<strong>git config --global alias.commitall '!git add .;git commit'</strong> доб. все из текущей дир.
<strong>git commitall -m '...'</strong>
<strong>git config --global alias.commitall '!git add -A;git commit'</strong> добавит все из дир. проекта


<h2>08 Удаление и переименование файлов</h2>
<em>.gitignore с .idea </em>эта настройка д.б. глобальной на компе разработчика
<strong>git config --global core.excludesFile ~/.gitignore</strong>
удалили .gitignore
<strong>git add .gitignore</strong>
<strong>git commit -m Cleanup</strong> - можно без кавычек, если одно слово

<strong>git rm ... </strong>удалит один или несколько ф И добавит изм. в индекс
<strong>git rm -r src</strong> удалит директорию
<strong>git rm -r --cached src  </strong> удалит из индекса но оставит в рабочем каталоге
так делают, чтобы оставить ф. в раб. дир, но не отслеж в гит, кот. добавили туда по ошибке

<strong>--cached </strong>операция с индексом вместо раб. дир.
если у меня есть изменения в файле index.html, которые еще не не сохранены в репозитории
<strong>git rm index.html  </strong>приведет к ошибке. если надо:
<strong>git rm -f index.html  </strong>
c (.) зрения гит - это удаление старого и созд. нового
если добавить "удаленный" и "созданный" в индекс
гит поймет что было переименование
<strong>git mv hello.html index.html</strong>  - переименует ф и добавит это в индекс




<h1>ВЕТКИ </h1>


<h2>01 Введение</h2>

новую ф. мы реализуем в новой ветке - это <em>тематические ветки</em>
 для нового релиза новая ветка -<em>релиз-ветки</em>  если что-то меняется в мастере -
ошибка исправляется, м. сделать черипикинг
сочетание тематических и релизных веток называется <em>git-flow</em>


<h2>02 Создание и переключение</h2>

технически ветка - это спец. ссылка на коммит
ее можно посмотреть <strong>.git/refs/heads/</strong> но здесь их можно и не найти
для просмотра веток используется 
<strong>git branch </strong>
или <strong>git branch -v</strong> ветка и инфо о коммите, на кот. она указ. 
<strong>.git/HEAD</strong> там HEAD
коммит. на кот указ ветка наз ее <em>вершиной</em>
<strong>git branch feature</strong> создали новую ветку, новую ссылку на наш коммит
<strong>git checkout feature</strong>
<strong>git checkout -b feature</strong> создали ветку и перелкючились
технически ветка это ссылка на комит, 
но принадлежащ. ветке наз все коммиты кот нах по цепочке родителей на пути от вершины вниз 


<h2>03 Команда checkout при незакоммиченных изменениях</h2>

<strong>git checkout -f master</strong>   если не нужны сделанные изменения
<strong>git checkout --force HEAD</strong>
<strong>git checkout -f </strong> -просто отмена всего незакоммиченного
<strong>git stash</strong> спрятать (сохранить на потом)
<strong>git stach pop </strong>(достать их стэш) - можно на другой ветке (обычно ошибочно так выходит)
Если мы на новой ветке не меняли файл со старой ветки, а потом
начали что-то менять и не закоммитили. 
то можно переключиться на старую, ошибки не будет, файл в раб. дир. и в индексе останется измененным


<h2>04 Создание новой ветки из последних коммитов, передвижение веток</h2>
если мы что-то поделали и поняли что сделали все не там
<strong>git branch fix </strong>создали новую ветку для сделанных изменений( она на хэд)
<strong>git checkout fix </strong>ушли с ветки перед тем как ее менять
<strong>git branch -f master hash</strong>  == <strong>git branch --force master hash</strong> - 
мастера двигаем назад, откуда хотим чтоб отходила новая ветка
без форс б. ругаться что ветка уже есть
<strong>git branch -f master имяветки </strong> пусть мастер указывает туда же куда и имяветки (мало ли, надо нам)
<strong>git checkout -B master hash </strong> если такая ветка уже есть при -B он ее передвинет на hash


<h2>05 Состояние отделённой HEAD</h2>

<strong>git checkout hash</strong>
коммиты из состояния detached HEAD не участвуют ни в 1 из ветвей разработки
если мы забыли что мы в этом состоянии и сделали коммит, м. использовать черипик
<strong>git switch -c <new-branch-name></strong>   | --новое - в скринкасте нет!
<strong>Or undo this operation with:    </strong>       |
<strong>  git switch - </strong>                                     |
<strong>git cherry-pick hash </strong>- подробности позже


<h2>06 Восстановление предыдущих версий файлов</h2>

<strong>git checkout master index.html</strong>
<strong>git checkout hash index.html </strong> достаем в раб. дир. ф. на момент указанного коммита
и добавляется в индекс
<strong>git reset index.html</strong> сбросится индекс
если мы всего наменяли и один ф. хотим вернутьт
<strong>git checkout HEAD index.html</strong> передает из хэд в индекс и в раб. дир. 
а остальные оставляет измененными
<strong>git checkout index.html </strong>-передает из индекса в раб. дир
<strong>git checkout -- master</strong> - перекл на директорию мастер (если она есть!)
<strong>git checkout HEAD --master </strong>


<h2>07 Просмотр истории и старых версий, ~ и :</h2>

<strong>
git log
git log --oneline
git log master --oneline
git show hash
git show HEAD~
git show HEAD~~
git show HEAD~~ --quiet
git show HEAD~3
git show @~
</strong>
в Power Shell <strong>git show '@~'</strong>
<strong>git show master~</strong>
<strong>git show @~4:index.html</strong>
<strong>git show fix:index.html</strong> (fix - название ветки!)
<strong>git show :index.html</strong> -смотрим, что в индексе
<strong>git show :/sayBye</strong> (ищем по названию коммита или части) -можно несколько слов в кавычках или рег. выр.

<h2>08 Слияние перемоткой</h2>

<strong>
git checkout master
git merge fix
</strong>
<strong>CAT .git/ORIG_HEAD</strong>  - перед merge запис. старое полож. ветки
<strong>
git branch -f master ORIG_HEAD
git checkout -B master fix
</strong>


<h2>09 Удаление веток</h2>

<strong>git branch -d fix </strong>- только слитую ветку (fix - это ветка)
<strong>git branch -D feature</strong> - Удалит не слитую ветку
<strong>git branch feature hash</strong> - создает обратно


<h2>10 Лог ссылок: reflog</h2>

<strong>cat .git/logs/HEAD</strong>
<strong>git reflog</strong>   == <strong>git log --online -g</strong>
<strong>git reflog feature</strong> (feature - это ветка)
<strong>git branch feature HEAD@{6}</strong> (в powerShell 'HEAD@{6}')
<strong>git reflog --date</strong>
<strong>git reflog --date=iso</strong>
<strong>git branch feature HEAD@{2020-04-09 22:25:59 +0300}</strong>
<strong>
    gc.reflogExpire = "90 days ago"
    gc.reflogExpireUnreachable = "30 days ago"
</strong>
<strong>git checkout @{-1} </strong>- предыдущая ветка, с кот. был чекаут на текущую
<strong>git checkout @{-5}</strong>
<strong>git checkout -</strong> предыдущая

<h2>11 Сборка мусора </h2>

git идет от каждой ветки, тега, HEAD  по цепочке родителей до конца. + reflogs - остаются в базе
автоматически запускается при выполнении команды слияния и при загрузке данных с сервера
или вручную 
<strong>git gc</strong>
gc - <em>garbage collection</em>
сборка мусора + внутр. оптимизации
<strong>gc.pruneExpire = "2 weeks ago"</strong>  prune - подрезать, обрезать, подстричь
<strong>git fsck unreachable </strong>- выводит список недостижимых коммитов
<strong>git filter-branch</strong> - позв. заменить коммиты ветки на нов. получ. из старых путем фильтрации
но удобнее сторонняя утилита <em>BFG</em>
<strong>git reflog expire --expire=now --all</strong>  - очищает reflog
<strong>git show d645 </strong>все еще покажет удаленный коммит
<strong>git show d645 --quiet</strong>
<strong>git gc --prune=now</strong> - чистит все коммиты моложе чем сейчас
<strong>git merge --no-ff --no-edit feature</strong>
<strong>git show --first-parent</strong>




<h1>ТЕГИ</h1> 


<h2>01 Теги, основные действия с тегами </h2>

<strong>git tag v1.0.0 5f91</strong>
<strong>git show v1.0.0 --quiet</strong>
тэг видно в git log
<strong>git tag</strong> - список тэгов
<strong>git tag --contains hash</strong> - Какие релизы содержат этот коммит
<strong>git tag -n</strong> - какие соообщения на помеченном коммите
<strong>git tag -n4 </strong>- 4 строки из сообщения
<strong>git log --oneline v1.0.0</strong> - история разработки от этого тэга (к началу)
<strong>git tag -n -l 'v1.1*'</strong> начинаются на v1.1
<strong>git tag -d v1.o.o v1.1.0 </strong>   удалит теги
<strong>git tag -a -m 'Version 1.0.0' v.1.0.0 f94f</strong> тег с аннотацией


<h2>02 Использование тегов для экспорта с describe, archive</h2> 

<strong>git describe hash</strong> - получить тэг 
<strong>git describe</strong> опишет HEAD
<strong>git archive -o /tmp/v1.1.</strong>


<h1>RESET</h1>
<h2>01 Жесткий reset, отмена коммита</h2>

<strong>git reset @~</strong>   родитель текущ. коммита  
<strong>git reset --hard @~  </strong>как будто последнего коммита никогда не было
<strong>cat .git/ORIG_HEAD</strong>
<strong>git reset --hard ORIG_HEAD</strong>
накуролесили с файлом -> добавили в индекс -> хотим вернуться к последнему коммиту:
<strong>git reset --hard</strong> == <strong>git reset --hard HEAD</strong>

<h2>02 Мягкий reset, замена и объединение коммитов</h2>

<strong>git reset --soft </strong> не трогает рабочую директорию и индекс
<strong>git commit -c ORIG_HEAD </strong>c открытием редактора и именем последнего коммита
<strong>git commit -C ORIG_HEAD</strong> то же без откр.ред. автор и дата те же
<strong>git show --quiet --pretty=fuller</strong> покажет дату создания и дату коммита
<strong>git commit -C ORIG_HEAD --reset-author</strong>

<h2>03 Правка последнего коммита: commit --amend</h2>

<strong>git commit --amend</strong>  == <strong>git reset --soft @~; git commit -C ORIG_HEAD</strong>
<strong>git commit --amend --reset-author</strong>
<strong>git commit --amend --no-edit </strong>отменяет вызов редактора
<strong>git commit --amend -m 'new commit name'</strong>
<strong>git reset --soft @~2</strong>
<strong>git commit -m 'sayHi and sayBye'</strong>  теперь изменения из 2 последних коммитов стали в одном
поменять коммит посередине ветки не трогая коммит за ним, нельзя:
переписыванием истории занимается <strong>git rebase</strong>

<h2>04 Смешаный reset, отмена индексации</h2>

<strong>git reset --mixed</strong> перемещ ветку сбрас индекс но не трог раб директор режим ресета по умолчанию так что:
<strong>git reset</strong> == <strong>git reset --mixed</strong>
<strong>git reset HEAD</strong> очистка индекса == <strong>git reset</strong>
смешанный ресет позволяет указ. конкр.. пути, т.е. сбросить из индекса один файл:
<strong>git reset index.html</strong>
<strong>git reset hash index.html</strong> - в индекс попадает версия файла из указанного коммита но лучше:
<strong>git checkout hash index.html</strong>  - т.к. помещает ф. не только в индекс но и в рабочую директорию

<h2>05 Жесткий reset с сохранением изменений: --keep</h2>

<strong>git reset --keep @~</strong> если статус чистый, тоже что <strong>git reset --hard @~</strong>
<strong>git diff --name-only @~</strong> какие файлы менялись в последнем коммите
<strong>git reset --keep @~</strong> если есть измененные не проинд. файлы, постарается их сохранить или выдаст error

<h2>06 Особый reset для отмены слияний: --merge</h2>

<strong>git reset --merge</strong>
если в раб. дир. изменения непроиндекс - сохраняются
проиндексированные все отмeняются

<h2>07  Виды reset – таблица в документации</h2> 

<strong>git help reset</strong>


<h1>ОЧИСТКА ПРОЕКТА ОТ ИЗМЕНЕНИЙ</h1>

<strong>git reset --hard</strong> и<strong> git checkout -f</strong> НИЧЕГО не делают с файлами, кот. не отслеж. git
<strong>git clean</strong>
<strong>git clean -d</strong> удаляет не только файлы но и директории
<strong>git clean -dx</strong> удаляет в т.ч. ф которые в .gitignore
<strong>git clean -f</strong> - это что мы уверены что все удаляем иначе не работает


<h1>ПРОСМОТР</h1>

<h2>01 Сравнение коммитов, веток и не только: git diff</h2>

<strong>git diff hash hash</strong>
<strong>git diff master feature</strong>  == <strong>git diff master..feature</strong>
<strong>git diff --no-pager</strong>  просмотр без листалки
<strong>git diff master...feature</strong> - сравн. что именно было сделано в feature с момента ее отхода от master
<strong>git diff feature...master</strong> - что сделано в мастере с мом. расх. с фичер
<strong>git diff hash </strong>- сравн. сост. раб. директории с репоз. на мом. этого коммита
<strong>git diff HEAD</strong> - сравн. что сделали в раб. дир. с последним коммитом (раб. дир. + индекс)
<strong>git diff</strong> то же, если ничего нет в индексе, а если мы туда добавили изменения ничего не выведет (только раб. дир. сравн.)
<strong>git diff</strong> не отслеживают новые непроиндексир. файлы, сравн. раб. директорию с индексом
<strong>git diff --cached</strong> или <strong>git diff --staged</strong> сравнивает с указанным коммитом то что в индексе
если не указ. коммит - то с HEAD
<strong>git commit -v</strong> коммитит с открытием diff в редакторе все что после <strong>>8</strong> удалится
если такое надо всегда, можно вкл. в конфиг
<strong>git config --global commit.verbose true</strong>
<strong>git diff index.html</strong>
<strong>git diff HEAD index.html</strong>
<strong>git diff master feature index.html</strong>
<strong>git diff master feature index.html script.js</strong>
<strong>git diff --name-only master feature</strong>
иногда перед путями ставят <strong>--</strong> (если напр. есть папка master или HEAD)
<strong>git diff -- master</strong> (master - Путь)
<strong>git diff master:one.html feature:two.html</strong>
<strong>git diff --no-index path1 path2</strong> - сравн. любые 2 ф. на диске независимо есть ли репозиторий

<h2>02 Сравнение по словам, драйвер diff</h2>

<strong>git diff --word-diff</strong>
<strong>git diff --color-words</strong> == <strong>git diff --world-diff=color</strong>
чт. поним не просто любые симв. мду пробелами м. задать в <em>.gitattributes</em>
<strong>*.html diff=html</strong>
html - это драйвер встроенный в Git 
<strong>*.css diff=css</strong>
рассказ. про созд. своих драйверов
<strong>
    [diff  "markdown"]
    	# POSIX extended
        xfuncname = "^#+[[:space:]]+.+$"
</strong> 
в .gitattributes  
<strong>
    *.md diff=markdown
    wordRegex ="\\*+|[^[:space:]*]+"
</strong>

м. передать рег. выр. через <strong>--word-diff-regex</strong>
встроенн. драйвера м. посмотреть в исходниках git в <em>userdiff.c</em>

<h2>03 Сравнение разных форматов, кастомизация diff</h2>

бинарные файлы
файл and Файл differ
в .gitconfig 
<strong>
    [diff "image"]
    	textconv = identify
</strong> утилита кот. выводит размер картинок
в .gitattributes 
<strong>*.png diff=image</strong>
<strong>git config diff.image.textconv "identify -format '%wx%h %b\n'"</strong>
<strong>
    [diff "image"]
    	textconv = identify -format '%wx%h %b\\n
    	cachetextconv = true
    	binary = true
    [diff "binary"]
    	binary = true
</strong>
в .gitattributes 
<strong>*.svg diff=binary</strong>
binary  == -text -merge -diff
<strong>
    [diff "icdiff"]
    	command = icdiff
</strong> сторонняя утилита - почитать отдельно!!
<strong>*.html diff=icdiff</strong>
<strong>git difftool</strong>

<h2>04 Вывод истории: git log, форматирование коммитов</h2>

<strong>git log</strong> выводит коммиты достижимые из HEAD
<strong>git log --pretty=oneline</strong>
<strong>git log --pretty=oneline --abbrev-commit</strong> == <strong>git log --oneline</strong>
<strong>git commit --author=... --date=...</strong> (чтобы коммитер отлич. от автора)
git использует для форматирования дат ф-ю strftime
<strong>git config --global pretty.my format: ".............."</strong>
<strong>git config --global format.pretty my</strong>
<strong>git config --global log.date format-local: "%F %R"</strong>
<strong>git log --patch</strong> == <strong>git log -p </strong> выводит лог с diff-ами
<strong>format: '%C(yellow)%h %C(dim green)%ad %C(reset)| %C(cyan)%s%d %C(#667788)[%an]'</strong>
<strong>git config --global --replace-all  pretty.my format:'%C(yellow)%h %C( green)%ad %C(reset)| %C(white)%s%C(magenta)%d %C(blue)[%an]'</strong>  
-у меня так заработало
<strong>git config --global log.date format-local:'%Y-%m-%d %H:%M:%S'</strong> ... и так

<h2>05 Диапазоны коммитов для git log и не только</h2>

<strong>git log hash</strong> выведет коммиты достижимые из hash
<strong>git log master feature</strong> и оттуда и оттуда
<strong>git log master feature --graph</strong>
<strong>git log --all --graph</strong>
<strong>git gui</strong>
<strong>git log feature ^master</strong> коммиты из feature кроме достижимых из master == <strong>git log master..feature</strong>
<strong>git log HEAD..feature </strong>
<strong>git log ..feature</strong>
<strong>git log feature..master</strong> (если HEAD на master) == <strong>git log feature..</strong>
в вышеперечисл. отсутствует пограничный коммит
<strong>git log feature.. --boundary</strong> - добавит пограничн. коммит
<strong>git log master...feature</strong> <em>симметрическая разность</em> коммиты кот. достижимы из одного другого но не из обоих одновременно
<strong>git help revisions</strong>
в diff (.) означают одно, а в остальных командах другое

<h2>06 Вывод git log коммитов, меняющих нужный файл</h2>

<strong>git log index.html</strong>
<strong>git log -p index.html</strong> - с diff-ами
<strong>git log --follow index.html</strong> - если в процессе разраб. ф. был переименован, то лог его все равно найдет
<strong>git log feature..master index.html</strong>
<strong>git log feature..master -- index.html</strong> - если имя ф. совпад. с им. ветки


<h2>07 Поиск в истории, фильтры для git log</h2>

<strong>git log --grep run</strong> поиск всех коммитов со словом run в описании c учетом текущей ветки
<strong>git log --grep added --grep function</strong> коммиты со словом added <em>ИЛИ</em> словом function
<strong>git log --grep added --grep function --all-match</strong> <em>И</em>
почитать <em>Дж.Фридл "Регулярные выражения"</em>
по умолч. гит использ. очень старый стандарт рег. выр.
<strong>git log --grep 'say(Hi|Bye)' -P </strong>флаг включает перл-совместимые р.в.
<strong>git config --global grep.patternType perl</strong>
<strong>git log -F</strong> отключает рег. выраж.
<strong>git log --grep sayhi -i</strong>   отключает учет регистра
<strong>git log -G регулярка </strong>- выведет все коммиты в diff-ами где она есть
<strong>git log -GsayHi -p</strong>
<strong>git log -L </strong>
<strong>git log -L 3,6:index.html </strong> с 3 по 6 стоки
<strong>git log -L '/&lt;head&gt;/','/&lt;\/head&gt;/':index.html</strong> в head
<strong>git log -L :sayHi:script.js </strong> ищет изменения ф-ции этот способ не идеален!
<strong>git log --author=ase444ka</strong>
<strong>git log --committer=ase444ka</strong>
<strong>git log --before '3 months ago'</strong>
<strong>git log --before '2020-04-12'</strong>
<strong>git log --after </strong>


<h2>08 Кто написал эту строку? git blame</h2>

<strong>
git blame index.html
git blame index.html --date=short -L 5,8
</strong>


<h1>СЛИЯНИЕ</h1>

<h2>01 Истинное слияние и разрешение конфликтов в git merge</h2>

<strong>git merge-base master feature </strong>  находит последний коммит то расхождения
<strong>git show hash:index.html</strong> покажет файл
<em>base ours-master theirs-feature</em>
base + our + their = merge
<strong>cat .git/MERGE_HEAD</strong> Указатель на ветку, С КОТОРОЙ слияние
<strong>git diff -U0 hash master  index.html</strong> покажет по 0 строчек вокруг изменений, по умолчанию 3
<strong>git checkout --ours index.html</strong>
<strong>git checkout --theis index.html</strong>
<strong>git checkout merge index.html</strong>
<strong>git reset --hard </strong> вновь окажемся на чистом статусе в HEAD
<strong>git reset --merge</strong> == <strong>git merge --abort</strong> оставляет незакоммиченные ф. кот. не участвовали в слиянии
слияние внесет изменения в раб. директорию и индекс только для тех ф. кот. в др. ветке изменены
т.о. на  изменения кот. слияние не затронуло, git reset --merge не повлияет
<strong>git checkout --conflict=diff3 --merge index.html</strong>
<strong>git config --global merge.conflictStyle diff3</strong>
<strong>git show :1:index.html</strong> посм. общего предка
<strong>то же 2</strong> наша
<strong>то же 3</strong> их
в индексе при конфликте находятся все 3 версии
пока так, многие команды гит, в т.к. коммит не работают
после исправлений, <strong>git add index.html</strong>
для завершения слияния <strong>git commit</strong> == <strong>git merge --continue</strong>


<h2>02 Коммит слияния, дальнейшие слияния</h2>

<strong>git show</strong>
<strong>git show hash</strong>
<strong>combined condensed diff смотрим, как разрешились конфликты</strong>
<strong> +</strong>  изменения в theirs (из ours)
<strong>+  </strong>из theirs
<strong>++ </strong>ни там ни там
<strong>git show --first-parent</strong> какие изменения наша ф-я привнесла в ветку мастер
<strong>git show -m </strong>показывают изменения всех участников слияния
<strong>git diff HEAD^</strong> -отличие от первого родителя
<strong>git diff HEAD^2 </strong> -//- от второго ..
<strong>.. HEAD^^</strong> родитель первого родителя
<strong>HEAD^2^ </strong>родитель второго родителя
<strong>^число</strong> когда несколько родителей
<strong>~число</strong> - к прародителям
<strong>git branch --merged</strong> показывает ветки, объединенные с текущей
<strong>git branch --no-merged </strong>показывает не объединенные
допустим изменили снова слитую с мастером ветку (без конфликтов)
<strong>git merge feature -m  'название коммита'  </strong> 
<strong>git merge feature --no-edit</strong>  у меня без --no-edit Слилось без редактора, написало "Merge made by the 'recursive' strategy."
<strong>git merge feature --log=5 </strong>не более 5, по умолч. не более 20  у меня не получилось, сделался Fast-forward
<strong>git log master --oneline</strong> покажет все коммиты в т.ч. слитых веток
<strong>git log master --oneline --first-parent</strong>  лог если видит коммит слияния идет дальше только по первому родителю
чтобы было ровно, надо сливать всегда из мастера!!


<h2>03 Отмена слияния</h2>
<strong>git reset --hard @~</strong>
хоть и два родителя, сам коммит только в ветке в которую слили
 если отменили коммит, но хотим вернуть, это можно, найти отмененный коммит м. в reflog
<strong>git reflog -4</strong>
<strong>git reset --hard @{1}</strong> (например)


<h2>04 Семантические конфликты и их разрешение</h2>

изменения конфликтуют по смыслу, а не по месту в файле
если нечаянно смерджили:
<strong>git reset --hard @~</strong> отмена
<strong>git merge work --no-commit</strong> и окажемся в состоянии преравнного слияния
<strong>cat ./git/MERGE_HEAD</strong>  файл с hash сливаемого коммита
<strong>git merge --continue</strong> == <strong>git commit</strong>


<h2>05 Слияние с сохранением веток, запрет перемотки --no-ff</h2>

<strong>git merge feature --no-ff</strong>
<strong>git show --first-parent</strong>
<strong>git.config merge.ff false</strong>
<strong>git.config branch.master.mergeoptions '--no-ff'</strong>
если такое настроено, можно включить явно:
<strong>git merge --ff feature</strong>


<h2>06 Слияние без связи с источником: merge --squash</h2>

Если у нас аддские эксперименты в ветке  fix и мы хотим одним коммитом заить ее результат в нашу ветку
<strong>git merge --squash fix</strong>
<strong>git diff --cashed</strong>
<strong>git commit -m 'то и это'</strong>
<strong>git branch -D fix  </strong>можно удалить ветку фикс

если конфликт:
<strong>git merge --squash feature</strong>
<strong>Auto-merging index.htm</strong>l
CONFLICT (content): Merge conflict in index.html

отменим
<strong>git merge --abort</strong>
<strong>fatal: There is no merge to abort (MERGE_HEAD missing).</strong> не получится

<strong>git reset --merge</strong>  так работает
когда конфликт, в индекс помещаются оба изменения
, не закоммитить пока не разреш. конфл:
Unmerged paths:
  (use "git restore --staged &lt;file&gt;..." to unstage)
  (use "git add &lt;file&gt;..." to mark resolution)
        both modified:   index.html

конфликт также м. дать др. команды, например
<strong>git stash pop</strong>


<h2>07 Слияние без конфликтов через драйвер union, свои драйверы</h2>

драйвер слияния задается в .gitattributes
по умолчанию txt Ф задается д. text
<strong>*.txt merge=text</strong>
для бинарн. по умолч. binary
<strong>*.jpg merge=binary</strong>
есть еще <em>union</em>
<strong>/NEWS.ms merge=union</strong>
union просто вставляет все изменения в файл
в union если в 1 ветке мы удалим какую-то стр. а в др. поменяем существующую, объед. версия вкл. в себя
все строки, котор. есть хотя бы в 1м файле
т.е. кот была удалена в одной из веток, останется
при слиянии идут сначала наши строки, а потом вливаемые
можно создать свой драйвер слияния
свой др. слияния создается в конфиге
<strong>
    [merge "po"]
    	name = Gettext merge driver
    	driver = git-merge-po.sh %O %A %B
</strong>     путь к ф. из общ. предка, путь к нашей верс. ф., путь к в.ф. из слив. ветк.

есть др. параметры, см. git help attributes
когда драйвер создан, его надо назначить чз .gitattributes
<strong>*.po merge=po</strong>


 <h2>08 Стратегии слияния</h2> 
<em>
recursuve
octopus
ours
resolve
subtree
</em>

<em>recursive</em> - ours - конфл. в нашу пользу, theirs - б. выбираться сливаемый вариант
git merge -Xours &lt;commit&gt;
git merge -Xtheirs &lt;commit&gt;
<em>renormalise</em> - нормализует концы строк для всех участвующих ф.
<em>ignore-all-space</em> - для работы с пробелами; четыре пробела и таб не конфликт
если в одной ветке изменили чуть файл, а в др. переименовали и чуть изменили, конфл. не будет,
если git видит один файл и другой новый, кот. отлич от нашего <=50%, он считает, что это переименованный наш
<strong>-Xno-renames</strong> эту стратегию отменяет
<strong>git merge -Xfind-renames=80 work</strong>
<strong>subtree=path </strong>позволяет замерджить одну ветку в поддиректорию другой
<strong>git merge -Xsubtree=plugin --allow-unrelated-histories plugin</strong>
<strong>git subtree</strong>
также для интеграции сторонних репозиториев есть
<strong>git submodule </strong>- В директорию проекта помещается не ветка, а сторонний репозиторий целиком


<em>octopus</em> исп-ся автоматич, когда треб. объединение более 2 веток 
его основная область, большие проекты с изменениями в разных местах

<strong>git merge -s ours hash</strong>
говорит полностью игнорировать содержимое сливаемой ветки
 
<em>resolve</em> очень старая и ненужная recursive полностью ее заменяет

<em>subtree</em> т.ж. что subtree в рекурс. слиянии. но в нее нельзя передавать путь




<h1>КОПИРОВАНИЕ КОММИТОВ</h1>


<h2>01 Копирование коммитов: cherry-pick</h2>

<strong>git cherry-pick D</strong>
берет diff указанного коммита и применяет его к текущей ветки, создавая новый коммит эти два коммита
называют эквивалентными, т.к. они содерж. одинаковые изменения
D D' - эквив. коммиты
<strong>git cherry-pick -x</strong>   x добавляет в описание коммита строку с инфой, откуда он был скопирован
<strong>git cherry-pick hash hash</strong> черипикинг нескольких коммитов (начинает с более раннего коммита)
<strong>git cherry-pick master..feature </strong> - или диапазона (все коммиты фичер, кот. нет в мастер)
если ошибка слияния   
<strong>git cherry-pick abort</strong> - отменит скопированные коммиты и вернет все как было до chp
<strong>git cherry-pick continue </strong>продолжит
<strong>git cherry-pick quit</strong> применит что применилось и дальше не пойдет
<strong>git reflog --no-decorate -3</strong>
<strong>git reset --hard HEAD@{2}</strong>
<strong>git cherry-pick no-commit has</strong>h == <strong>git cherry-pick -n hash</strong>  внесет изменения в раб. дир. и индекс, мы сможем подредактировать что надо
<strong>git diff --cached</strong>

<h2>02 Просмотр эквивалентных коммитов: cherry, cherry-mark</h2>

можно обмениваться изменениями чз форумы, чаты, емейлы, используя команды 
<strong>git patch</strong>
<strong>git apply</strong>
и др..
<strong>git cherry master feature</strong> - покажет коммиты из f которым есть экв. в мастер
<strong>- </strong>коммит, у которого есть копия в мастер
<strong>+ </strong>нет копии
<strong>git cherry master feature -v </strong>  с описанием
если указать только одну ветку, вторая равна HEAD
<strong>git cherry feature </strong>- покаж. коммиты из HEAD кот. есть экв. в Feature
но можно <strong>git log feature...master</strong>
<strong>git log --cherry-pick feature...master</strong> удаляет эквив. коммиты из вывода
<strong>git log --cherry-mark feature...master</strong> помечает э.к.
<strong>git log --cherry-mark --oneline --left-right feature...master</strong>   знаком больше комм. из правой в. меньше из левой
<strong>git log --cherry-mark --oneline --left-only feature...master  </strong>только из feature
--right-only только из мастер
<strong>git log --oneline --cherry</strong>  == <strong>git log --right-only --no-merges </strong> (?)



<h1>ПЕРЕМЕЩЕНИЕ КОММИТОВ</h1>


<h2> 01 Перебазирование веток: rebase</h2> 

находимся на feature
<strong>git rebase master</strong> перебазирует feature на master
Если посередине застрянет,
<strong>git reset --hard </strong>не сработает, т.к. рипозиторий наход. в состоянии detached HEAD
<strong>git rebase --abort</strong>
<strong>git rebase --quit</strong>   не возвращает обратно HEAD
<strong>git rebase --skip </strong>пропустит конфликтный коммит
коммиты, которые изменения не дают, называют пустыми, и rebase их пропускает автоматически 
Допустим, мы передумали
вначале работы rebase создает ORIG_HEAD
<strong>cat .git/ORIG_HEAD</strong>
так что как правило все вернет
<strong>git reset --hard ORIG_HEAD</strong>
Если вдруг удалилось м. посмотреть reflog Именно ветки
<strong>git reflog feature -1</strong>
<strong>git show --quiet feature@{1}</strong>
<strong>git rebase master feature </strong> означает, что нужно перенести feature на master

<h2>02 Rebase против merge: сравнение подходов</h2>

главный <em>плюс</em> rebase - упрощение истории разработки
<em>sourcetree</em> - графич. утилита для работы с git
<em>минус</em> - коммит в ребэйс может оказаться "сломанным": напр. вызвал переименованную в мастере функцию
еще минус, когда два разработчика работают над одной и т.ж. веткой
<strong>git rebase -x '...' master</strong> позволяет запускать <em>команду</em> в кавычках после каждого коммита (обычно это тесты)

<h2>03 Тесты при rebase, rebase -x</h2>

<strong>git rebase -x 'node feature.js' master</strong>
исправили
<strong>git add feature.js</strong>
<strong>git commit --amend --no-edit</strong>
<strong>git rebase --continue</strong>


<h2>04 Перенос части ветки, rebase --onto</h2>

чтобы указать с какого момента нужно копировать
<strong>git rebase --onto master feature</strong>  надо перебаз. на мастер текущ ветку (fix) начиная с указателя на feature ==
<strong>git rebase --onto master feature fix</strong>

rebase и ch-p иногда заменяют др. друга
<strong>git checkout feature</strong>
<strong>git cherry-pick master~2..master</strong>
<strong>git branch -f master master~2</strong>


<h2>05 Перебазирование слияний, rebase -p</h2>

<strong>git rebase --preserve-merges master</strong> ==<strong> git rebase -p master</strong>
сохраняет коммиты слияния (по умолчанию - нет)
при такой опции, коммит слияния копируется, а также коммиты из сторонней ветки (до слияния) НЕ КОПИРУЮТСЯ!

, но к сожалению, проблема остается, если в комм. слияния разрешали конфликт, то изменения пропадут (середина 2018г сейчас- проверить!)
поэтому рекоменд. избегать перебазирования веток со слияниями


<h2>06 Интерактивное перебазирование, rebase -i</h2>

<strong>git rebase --edit-todo </strong>Если сделали пару коммитов посередине и надо посмотреть .что еще надо сделать
<strong>git rebase --continue</strong>
иногда интеракт перебаз. делают только для улучшения истории, тогда надо перебаз. ветку на саму себя
<strong>git rebase -i @~3</strong>
ребейз полностью копирует всю ветку, т.к. менять коммиты нельзя
но если в редакторе оставить первые коммиты Как pick, 
будут копир. коммиты с момента первого кот. не пик
если очень хочется перебазировать именно все, можно использовать флаг
<strong>--no-ff</strong>


<h2>07 Коммиты-заплатки: rebase autosquash</h2>

<strong>git commit -a --fixup=@~ </strong>
<strong>git commit -a --fixup=hash</strong>
такой коммит в начало имени коммита ставит "fixup! название редактируемого коммита"
но позже если запусить интерактивное перебазирование
<strong>git rebase -i --autosquas</strong>h
или вкл. ее глобально по умолчанию
<strong>git config --global rebase.autoSquash true</strong>
по при ребайз автоматически заплатка поставится после нужного коммита с фиксапом 


<h1>RERERE</h1>


<h2>01 Авторазрешение повторных конфликтов</h2>
<em>REuse REcorded REsolution</em>
<strong>git config rerere.enabled  true</strong>
при конфликте появится надпись
<strong>Recorded preimage for 'index.html' </strong> - означает. что ререре запомнил состояние файла на мом. конфликта
разреш. конфл
<strong>git add index.html</strong>
<strong>git commit --no-edit</strong>
И появл. <strong>Recorded resolution for 'index.html'</strong>.
<strong>git config rerere.autoUpdate true</strong> тогда rerere будет добавлять результат исправления конфл. в индекс
если запомненное решение конфликта нам не подходит, можно получить файл с конфликтом:
<strong>git checkout --merge index.html</strong>
<strong>git rerere forget index.html</strong> забыли старое разрешение конфликта
сделали по-другому 
<strong>git commit -a --no-edit</strong>
<strong>.git/rr-cache/</strong> тут все данные по конфл. rerere
можно удалить махом все данные по разреш. конфл.
<strong>rm -rf .git/rr-cache</strong>
также это удаляет сборщик мусора, если они старше чем в конфиге <strong>rerere.rerereResolved </strong>(60 дней)
<strong>rerere.rerereUnresolved </strong>(15 дней)
если Rerere надоел
<strong>git config rerere.enabled false</strong> либо
<strong>git config --unset rerere.enabled </strong>но тогда еще нужно убить директорию <strong>.git/rr-cache</strong>
<strong>rerere-train.sh</strong> скрипт обучения rerere обычно встроен в git
если включили уже после повторения конфликта можно обучить:
<strong>путь к rerere-train.sh --all</strong>



<h1>ОБРАЩЕНИЕ КОММИТОВ</h1>


<h2>01 Обратные коммиты, revert</h2>

создает противоположный коммит
можно указать диапазон
<strong>git revert A..D</strong> создаст коммиты B^ C^ D^
git revert поддерживает практически все флаги команды cherry-pick


<h2>02 Отмена слияния через revert</h2>

<strong>git revert -m 1 @ </strong>
смотрим, чего наотменяли
<strong>git diff @~</strong>
если потом пофиксили баги в фичер и снова хотим слить с мастер,  
в мастере лучше произвести отмену отмены слияния перед этим
иначе будут конфликты, гит не понимает что отмена вообще была


<h2>03 Повторное слияние с rebase</h2>

<strong>git rebase --onto master f94fdd feature</strong>  (c момента расхождения до первого слияния)
<strong>git checkout master</strong>
<strong>git merge --no-ff --no-edit feature</strong>
т.о. не потребовалось дополнительных финтов ушами типа отмены отмены 
но это удобно только если это наша ветка без проблем с синхронизацией с коллегами


второй вариант: чтобы убрать переплетения с мастер, перебазируем фичу рядом с собой с момента расхождения
<strong>git checkout feature</strong>
<strong>git rebase f94fdd --no-ff</strong>

<h1>ДАТЫ В GIT</h1>

<h2>01 Передача даты в гит, форматы дат</h2>

<strong>30.01.2018
01/30/2018
2018-01-30
2018.01.30
</strong>
можно в виде юникс-таймстампа
коммиты до второго января берутся до 2 января времени которое сейчас
если брать только дату, время укажется текущее
если только время, дата возьмется текущая 
врем. зона берется текущая
можно указать время как 4pm
<strong>3 weeks = 3 weeks ago = 3.weeks.ago</strong>
<strong>3 day = 3 days = 3 days ago</strong> и т.д.
<strong>git log --before = '2 day'</strong>
<strong>git log --before = 3.day </strong>так можно без кавычек, удобно
можно
<strong>1 year 2 months 5 minutes 1 second</strong>
<strong>one year two months </strong>(умеет считать от нуля zero до десяти)
<strong>
yesterday
midnight
noon
</strong>
<strong>tea </strong>пять вечера
<strong>last friday</strong>
<strong>
never 
now
</strong>
<strong>git config --global gc.reflogExpire=never</strong> рефлог не будет чиститься никогда
<strong>git reflog expire --expire=now --all </strong>очистит все рефлоги
<strong>git reflog expire --expire=all --all</strong>

<h2>02 Форматирование для вывода дат</h2>

<strong>git log --date=</strong>
<em>
default
rfc
iso
iso-strict
short
unix
raw
relative
</em>
<strong>format: '%F$T'</strong> см. <em>strftime</em>
ко всем форматам можно применить суфф. <em>-local</em> чтобы переводить даты в локальную таймзону
(если мы разрабатываем в команде с иностранцами)
<strong>git log --date=iso-local</strong>
<strong>git log --date=format-local: '%F %T'</strong>
</pre>
<script src="html5outliner-master/bookmarklet.js"></script>
</body>

</html>